/**
 * Natural Language Query Report API
 *
 * POST /api/admin/reports/query
 *
 * Accepts a natural-language question (or a pre-validated SQL string for re-use
 * in export requests) and returns either JSON data or an Excel/CSV file.
 *
 * Security:
 *  - Requires wedding_admin role
 *  - SQL is generated by the LLM and validated by nl-query.ts before execution
 *  - All data is scoped to the authenticated user's wedding only
 *  - Pre-supplied SQL (for exports) is re-validated before execution
 */

import { NextRequest, NextResponse } from 'next/server';
import * as XLSX from 'xlsx';
import { requireRole } from '@/lib/auth/middleware';
import {
  executeNaturalLanguageQuery,
  executeValidatedSQL,
} from '@/lib/reports/nl-query';

type ExportFormat = 'json' | 'xlsx' | 'csv';

export async function POST(req: NextRequest) {
  try {
    const user = await requireRole('wedding_admin');

    if (!user.wedding_id) {
      return NextResponse.json(
        { error: 'No wedding associated with this account' },
        { status: 400 }
      );
    }

    const body = await req.json();
    const { question, sql: providedSql, format = 'json' } = body as {
      question?: string;
      sql?: string;
      format?: ExportFormat;
    };

    if (!question && !providedSql) {
      return NextResponse.json(
        { error: 'Either question or sql is required' },
        { status: 400 }
      );
    }

    // Execute the query (LLM path or re-execute path for exports)
    const result = providedSql
      ? await executeValidatedSQL(providedSql, user.wedding_id)
      : await executeNaturalLanguageQuery(question!, user.wedding_id);

    // ── JSON response ────────────────────────────────────────────────────────
    if (format === 'json') {
      return NextResponse.json({
        data: result.data,
        sql: result.sql,
        columns: result.columns,
      });
    }

    // ── File export ──────────────────────────────────────────────────────────
    const rows: (string | number | boolean | null)[][] = [
      result.columns,
      ...result.data.map((row) =>
        result.columns.map((col) => {
          const val = row[col];
          if (val === null || val === undefined) return '';
          if (typeof val === 'object') return JSON.stringify(val);
          return val as string | number | boolean;
        })
      ),
    ];

    const workbook = XLSX.utils.book_new();
    const worksheet = XLSX.utils.aoa_to_sheet(rows);

    // Auto column widths
    worksheet['!cols'] = result.columns.map((_, colIdx) => {
      const maxLen = Math.max(...rows.map((row) => String(row[colIdx] ?? '').length));
      return { wch: Math.min(Math.max(maxLen + 2, 10), 50) };
    });

    XLSX.utils.book_append_sheet(workbook, worksheet, 'Custom Report');

    const timestamp = new Date().toISOString().split('T')[0];

    if (format === 'csv') {
      const csv = XLSX.utils.sheet_to_csv(worksheet);
      return new NextResponse(Buffer.from(csv, 'utf-8'), {
        headers: {
          'Content-Type': 'text/csv',
          'Content-Disposition': `attachment; filename="custom-report-${timestamp}.csv"`,
        },
      });
    }

    // xlsx
    const buffer = XLSX.write(workbook, { type: 'buffer', bookType: 'xlsx' });
    return new NextResponse(new Uint8Array(buffer), {
      headers: {
        'Content-Type':
          'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
        'Content-Disposition': `attachment; filename="custom-report-${timestamp}.xlsx"`,
      },
    });
  } catch (error) {
    console.error('[NL-QUERY] API error:', error);
    const message =
      error instanceof Error ? error.message : 'Failed to execute query';
    return NextResponse.json({ error: message }, { status: 500 });
  }
}
