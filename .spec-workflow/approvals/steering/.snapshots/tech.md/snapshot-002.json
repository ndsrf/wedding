{
  "id": "snapshot_1768301698793_xzsum2vuv",
  "approvalId": "approval_1768301327838_f426s5vql",
  "approvalTitle": "Tech Steering Document - Technology Stack",
  "version": 2,
  "timestamp": "2026-01-13T10:54:58.793Z",
  "trigger": "approved",
  "status": "pending",
  "content": "# Technology Stack\n\n## Project Type\nMulti-tenant SaaS web application with mobile-first responsive design, optimized for WhatsApp in-app browsers. The platform serves wedding planners who manage multiple weddings for their clients, with distinct interfaces for platform administration, wedding planners, wedding admins (couples), and guest-facing RSVP pages.\n\n## Core Technologies\n\n### Primary Language(s)\n- **Language**: TypeScript\n- **Runtime/Compiler**: Node.js (LTS version)\n- **Language-specific tools**: npm for package management, TypeScript compiler for type checking\n\n### Key Dependencies/Libraries\n- **Next.js 14+**: Full-stack React framework with App Router for API routes and server-side rendering\n- **React 18+**: Frontend UI library with hooks and server components\n- **Prisma ORM**: Type-safe database access with automatic TypeScript type generation\n- **NextAuth.js**: OAuth authentication for Google, Facebook/Instagram, Apple providers\n- **next-intl**: Internationalization library for 5 languages (Spanish, English, French, Italian, German)\n- **Tailwind CSS**: Utility-first CSS framework for mobile-first responsive design\n- **Zod**: TypeScript-first schema validation for API inputs\n- **xlsx**: Excel file parsing and generation for guest list import/export\n- **Resend**: Transactional email service for invitations and reminders\n- **GoCardless SDK**: Bank Account Data API integration for automated payment matching\n- **standard-version**: Automated versioning and changelog generation following semantic versioning\n\n### Application Architecture\n**Multi-tenant SaaS with data isolation**: The architecture follows a monolithic Next.js application with clear separation between:\n- **Client Layer**: Four distinct UIs (Master Admin, Planner Dashboard, Wedding Admin Panel, Guest RSVP Pages)\n- **API Layer**: RESTful API routes organized by user role (`/api/master/`, `/api/planner/`, `/api/admin/`, `/api/guest/`)\n- **Service Layer**: Modular services for authentication, tracking, email, Excel processing, payment matching, and theme rendering\n- **Data Layer**: PostgreSQL with Prisma middleware enforcing `wedding_id` filtering for complete data isolation\n\nThe system emphasizes **modular design** with single-responsibility services, **mobile-first responsive interfaces**, and **progressive disclosure** to avoid overwhelming users.\n\n### Data Storage\n- **Primary storage**: PostgreSQL 15+ for all structured data (users, weddings, families, RSVPs, tracking events, payments)\n- **Caching**: Redis for theme configurations and static translations (optional for MVP, planned for future optimization)\n- **Data formats**: JSON for theme configurations (stored in JSONB columns), translation files in JSON format\n\n### External Integrations\n- **APIs**:\n  - OAuth Providers: Google, Facebook/Instagram, Apple (NextAuth.js integration)\n  - Resend API: Transactional emails (invitations, reminders, confirmations)\n  - GoCardless Bank Account Data API: Automated bank transaction polling for gift matching (optional automated mode)\n- **Protocols**: HTTP/REST for all API communications, HTTPS enforced in production\n- **Authentication**:\n  - OAuth 2.0 for admin authentication (master admin, planners, wedding admins)\n  - Magic links with persistent UUID tokens for guest authentication (no passwords)\n\n### Monitoring & Dashboard Technologies\n- **Dashboard Framework**: React 18+ with Next.js App Router for all four user-facing dashboards\n- **Real-time Communication**: WebSocket for live notification updates (future enhancement), polling fallback every 30 seconds\n- **Visualization Libraries**: Tailwind CSS for responsive layouts, custom charts for analytics dashboards\n- **State Management**: React hooks (useState, useContext) with Next.js server state, no global state management library for MVP\n\n## Development Environment\n\n### Build & Development Tools\n- **Build System**: Next.js built-in build system (Turbopack for development, Webpack for production)\n- **Package Management**: npm with package-lock.json for dependency locking\n- **Development workflow**: Hot module replacement via Next.js dev server, TypeScript watch mode\n\n### Code Quality Tools\n- **Static Analysis**: TypeScript compiler with strict mode enabled for type safety\n- **Formatting**: Prettier for consistent code style enforcement\n- **Linting**: ESLint with TypeScript and React rules\n- **Testing Framework**:\n  - Jest for unit and integration tests (80% minimum coverage target)\n  - React Testing Library for component testing\n  - Playwright for end-to-end tests across browsers (Chrome, Firefox, Safari, WhatsApp in-app browser)\n- **Documentation**: JSDoc comments for complex functions, inline code comments for clarity\n\n### Version Control & Collaboration\n- **VCS**: Git with GitHub for repository hosting\n- **Commit Convention**: Conventional Commits specification for structured commit messages (feat:, fix:, docs:, chore:, etc.)\n- **Versioning**: Semantic Versioning (SemVer) with automated version bumping based on commit types\n- **Branching Strategy**: Feature branches merged to `main` via pull requests\n- **Code Review Process**: All changes require peer review before merging\n- **Release Management**: GitHub Releases with automated changelog generation from conventional commits\n\n### Dashboard Development\n- **Live Reload**: Next.js hot module replacement for instant feedback during development\n- **Port Management**: Development server runs on port 3000 (configurable)\n- **Multi-Instance Support**: Each developer runs local instance with separate database\n\n## Deployment & Distribution\n\n- **Target Platform(s)**: Any VM or server supporting Docker and docker-compose (cloud-agnostic approach)\n  - Primary target: Hetzner VPS (CPX41: 8 vCPUs, 16GB RAM, 240GB SSD)\n  - Also compatible with: AWS EC2, Google Cloud Compute, DigitalOcean Droplets, Azure VMs\n- **Distribution Method**:\n  - Docker containers built via GitHub Actions and published to GitHub Container Registry (ghcr.io)\n  - Generated docker-compose.yml files included in GitHub Releases for easy deployment\n  - Semantic versioning tags on all releases (e.g., v1.2.3)\n- **Container Strategy**:\n  - Multi-stage Docker builds for optimized image size\n  - Separate containers: application (Next.js), database (PostgreSQL), reverse proxy (Nginx)\n  - Version-tagged images enable rollback to any previous release\n- **Installation Requirements**:\n  - Docker 20+ and docker-compose 2+ installed on target server\n  - Any Linux distribution with container support (Ubuntu 22.04 LTS recommended)\n  - Custom domain with DNS configured (optional for development)\n- **Update Mechanism**:\n  - **CI/CD Pipeline via GitHub Actions**:\n    1. Developer commits with conventional commit messages (feat:, fix:, etc.)\n    2. Push to `main` branch triggers GitHub Actions workflow\n    3. Automated tests run (unit, integration, E2E)\n    4. On success: `standard-version` bumps version based on commit types\n    5. Docker images built with version tags (e.g., `v1.2.3`, `latest`)\n    6. Images pushed to GitHub Container Registry\n    7. GitHub Release created with:\n       - Auto-generated changelog from conventional commits\n       - Docker images attached\n       - Generated docker-compose.yml for deployment\n    8. Deployment notification sent\n  - **Production Deployment**:\n    1. Pull versioned docker-compose.yml from GitHub Release\n    2. Pull versioned Docker images from GitHub Container Registry\n    3. Run `docker-compose up -d` to deploy new version\n    4. Health check verifies application is running\n    5. Automatic rollback to previous version on health check failure\n  - **Zero-Downtime Strategy**: Blue-green deployment with container orchestration\n\n## Technical Requirements & Constraints\n\n### Performance Requirements\n- **Page Load Time**: Guest RSVP pages must load within 2 seconds on 3G mobile connections\n- **API Response Time**: < 500ms for 95th percentile of all API requests\n- **Database Queries**: < 100ms for typical queries, pagination required (50 items per page)\n- **Excel Import Speed**: Must handle up to 500 families in under 10 seconds\n- **Theme Rendering**: No visual jank, smooth transitions between theme changes\n\n### Compatibility Requirements\n- **Platform Support**:\n  - Browsers: Chrome, Firefox, Safari, WhatsApp in-app browser (primary)\n  - Devices: Mobile-first (iOS 12+, Android 8+), tablet, desktop\n  - Node.js: LTS version (v18+ recommended)\n- **Dependency Versions**:\n  - Next.js: 14+\n  - React: 18+\n  - PostgreSQL: 15+\n  - TypeScript: 5+\n- **Standards Compliance**: WCAG 2.1 AA for accessibility (elderly-friendly interfaces)\n\n### Security & Compliance\n- **Security Requirements**:\n  - HTTPS enforced in production via Let's Encrypt SSL certificates\n  - OAuth 2.0 with state parameters to prevent CSRF attacks\n  - Magic tokens use cryptographically secure UUIDs (crypto.randomUUID())\n  - HTTP-only, secure session cookies with 7-day expiration\n  - Zod schema validation on all API inputs\n  - Prisma parameterized queries to prevent SQL injection\n  - React's built-in XSS escaping for user input\n- **Compliance Standards**:\n  - GDPR compliance: data export and deletion capabilities for guests\n  - PII minimization: only collect necessary guest information\n  - Email verification for master admin access on every login\n- **Threat Model**:\n  - Multi-tenancy security: Prisma middleware automatically enforces `wedding_id` filtering on all queries\n  - Access control: verify user has access to requested wedding before any operation\n  - Rate limiting: prevent abuse of magic link generation and API endpoints\n  - Audit logging: log all cross-tenant access attempts\n\n### Scalability & Reliability\n- **Expected Load**:\n  - 50 wedding planners managing 8 weddings each (400 weddings)\n  - 100-150 guest families per wedding (40,000-60,000 families)\n  - 100 concurrent guests accessing RSVP pages simultaneously\n  - 1000 tracking events per minute during peak times\n- **Availability Requirements**: 99.5% uptime target with daily database backups\n- **Growth Projections**: Designed to scale to 200 planners in Year 2 (1,600 weddings, 160,000 families)\n\n## Technical Decisions & Rationale\n\n### Decision Log\n\n1. **Next.js 14+ with App Router**:\n   - **Why**: Unified full-stack framework eliminates need for separate frontend/backend. App Router provides excellent server-side rendering for SEO and mobile performance, with API routes co-located with pages for faster development.\n   - **Alternatives considered**: Separate React + Express stack (rejected due to increased complexity), Remix (rejected due to smaller ecosystem)\n   - **Trade-offs**: Vendor lock-in to Vercel ecosystem, but benefits outweigh risks for our use case\n\n2. **PostgreSQL + Prisma ORM**:\n   - **Why**: PostgreSQL provides JSONB support for theme configurations, excellent performance for relational data, and robust multi-tenancy support via row-level security. Prisma generates type-safe database access with automatic TypeScript types, reducing runtime errors.\n   - **Alternatives considered**: MongoDB (rejected due to lack of strong relational constraints), MySQL (rejected due to inferior JSON support)\n   - **Trade-offs**: Prisma adds abstraction layer but dramatically improves developer experience and type safety\n\n3. **Magic Links for Guest Authentication**:\n   - **Why**: Spanish families include elderly relatives uncomfortable with passwords. Magic links eliminate authentication friction, increasing RSVP completion rates. Persistent UUID tokens valid until wedding date ensure links never expire unexpectedly.\n   - **Alternatives considered**: Email/password authentication (rejected due to password fatigue), SMS OTP (rejected due to international SMS costs)\n   - **Trade-offs**: Less secure than password authentication, but mitigated by cryptographically secure UUIDs and wedding-scoped access\n\n4. **Multi-Tenancy via Prisma Middleware**:\n   - **Why**: Automatic `wedding_id` filtering on all queries prevents data leakage between weddings. Middleware approach is less error-prone than manual filtering in every query.\n   - **Alternatives considered**: Separate databases per wedding (rejected due to complexity), row-level security only (rejected as not sufficient alone)\n   - **Trade-offs**: Middleware adds minimal overhead but dramatically improves security posture\n\n5. **Mobile-First Design with Tailwind CSS**:\n   - **Why**: 95%+ of guest interactions happen on mobile devices, primarily via WhatsApp in-app browser. Tailwind's utility-first approach enables rapid mobile-first development with consistent spacing and touch targets â‰¥44px.\n   - **Alternatives considered**: Styled Components (rejected due to runtime overhead), Bootstrap (rejected as not mobile-first)\n   - **Trade-offs**: Tailwind classes can clutter JSX, but benefits to development speed and mobile optimization are critical\n\n6. **Docker Deployment on Self-Hosted VPS**:\n   - **Why**: Cost efficiency for early-stage startup, full control over infrastructure, predictable monthly costs. Hetzner provides excellent performance at low cost compared to AWS/GCP.\n   - **Alternatives considered**: Vercel hosting (rejected due to unpredictable costs at scale), AWS ECS (rejected due to complexity for small team)\n   - **Trade-offs**: Manual infrastructure management vs. managed services, but acceptable for MVP with proper automation\n\n7. **Resend for Transactional Emails**:\n   - **Why**: Modern API with excellent developer experience, reliable delivery rates, competitive pricing. Better deliverability than SendGrid/Mailgun for European recipients.\n   - **Alternatives considered**: SendGrid (rejected due to complex API), AWS SES (rejected due to setup complexity)\n   - **Trade-offs**: Smaller provider with less track record, but API simplicity and deliverability justify choice\n\n8. **next-intl for Internationalization**:\n   - **Why**: Native integration with Next.js App Router, supports 5 languages (Spanish, English, French, Italian, German), server and client-side rendering, excellent type safety.\n   - **Alternatives considered**: react-i18next (rejected due to less Next.js integration), custom solution (rejected due to time constraints)\n   - **Trade-offs**: Adds bundle size but multi-language support is non-negotiable for Spanish market with international guests\n\n9. **GitHub Actions + GitHub Releases for CI/CD**:\n   - **Why**: Native integration with GitHub repository, free for public repos and generous limits for private repos. Enables automated Docker image building, versioning, and release management. GitHub Container Registry provides reliable image hosting with direct integration.\n   - **Alternatives considered**: Jenkins (rejected due to infrastructure overhead), GitLab CI (rejected due to team familiarity with GitHub), CircleCI (rejected due to additional costs)\n   - **Trade-offs**: Vendor lock-in to GitHub, but team already uses GitHub for VCS and benefits outweigh migration risks\n\n10. **Conventional Commits + Semantic Versioning**:\n    - **Why**: Structured commit messages enable automated changelog generation and semantic version bumping. Makes release history human-readable and enables automated tooling. Helps team understand impact of changes (breaking vs. feature vs. fix).\n    - **Alternatives considered**: Manual versioning (rejected due to human error), Git tags only (rejected due to lack of changelog automation), Keep a Changelog manual process (rejected due to maintenance burden)\n    - **Trade-offs**: Requires team discipline to follow commit convention, but commitlint enforcement and clear guidelines mitigate this\n\n11. **Cloud-Agnostic Container Deployment**:\n    - **Why**: Docker + docker-compose provides portability across any infrastructure supporting containers. Enables easy migration between cloud providers, prevents vendor lock-in, and allows cost optimization by switching providers. Development and production environments are identical.\n    - **Alternatives considered**: Kubernetes (rejected due to complexity for MVP scale), Platform-specific deployments (AWS ECS, Google Cloud Run) rejected due to vendor lock-in, Vercel (rejected due to unpredictable scaling costs)\n    - **Trade-offs**: Manual orchestration vs. managed Kubernetes, but acceptable for MVP scale with proper automation scripts\n\n## Known Limitations\n\n- **Redis Caching Not Implemented in MVP**: Theme configurations and translations are fetched from database on each request, adding latency. **Impact**: Slower page loads for guest RSVP pages. **Future solution**: Add Redis caching layer in Phase 2 for 10x performance improvement.\n\n- **WebSocket Real-Time Updates Deferred**: Wedding admin notification updates use 30-second polling instead of real-time WebSocket connections. **Impact**: Admins see delayed notifications. **Future solution**: Implement WebSocket server in Phase 3 for instant updates.\n\n- **GoCardless Integration Optional**: Automated payment matching requires GoCardless API setup, which may not be available for all wedding planners. **Impact**: Manual payment recording required for planners without GoCardless. **Future solution**: Add Plaid or Tink integrations for broader bank coverage.\n\n- **No Offline Support**: Guest RSVP pages require active internet connection. **Impact**: Guests in areas with poor connectivity cannot submit RSVPs. **Future solution**: Implement service workers for offline form caching in Phase 5.\n\n- **Single Database Instance**: PostgreSQL runs on single VPS instance without replication. **Impact**: Database downtime affects entire platform. **Future solution**: Add read replicas and automated failover when revenue justifies cost (Year 2).\n\n- **Excel Import Memory Constraints**: Large Excel files (>1000 families) may cause memory issues during import. **Impact**: Wedding admins with very large guest lists cannot import all at once. **Workaround**: Split large imports into batches. **Future solution**: Implement streaming Excel parser in Phase 4.\n\n- **No Audit Trail for Data Changes**: System tracks events but not historical data changes (e.g., who edited which family's RSVP). **Impact**: Cannot trace data modification history for disputes. **Future solution**: Add comprehensive audit logging in Phase 6 for enterprise tier.\n\n- **Limited Theme Customization**: Theme editor supports colors, fonts, and spacing but not layout changes. **Impact**: Planners cannot create highly custom layouts for weddings with unique branding needs. **Future solution**: Add visual theme builder with drag-and-drop in Phase 7.\n",
  "fileStats": {
    "size": 18570,
    "lines": 249,
    "lastModified": "2026-01-13T10:53:20.275Z"
  },
  "comments": []
}